# -Inheritance-and-Polymorphism-
1.1.什么是继承
简单说就是：先有一个现成的 “基础类”（比如定义了 “手机” 基本功能：打电话、发短信），你不用从头写这个类的代码，直接在它的基础上加新功能（比如加拍照、连 WiFi），新造出来的这个类就叫 “派生类”（比如 “智能手机” 类）。在好久之前大家都用诺基亚手机，它的功能只有打电话跟发短信。随着时代的发展，我们发明了智能手机，我们不用重新打入“打电话”，“发短信”的代码，我们直接继承到智能手机就行
1.2.继承的语法
在Java中如果要表示类之间的继承关系，需要借助extends关键字
例子
// Animal.java
public class Animal{
String name;
int age;
public void eat(){
System.out.println(name + "正在吃饭");}
public void sleep(){
System.out.println(name + "正在睡觉");}
}
// Dog.java
public class Dog extends Animal{
void bark(){
System.out.println(name + "汪汪汪~~~");}
}
// Cat.Java
public class Cat extends Animal{
void mew(){
System.out.println(name + "喵喵喵~~~");}
}
// TestExtend.java
public class TestExtend {public static void main(String[] args) {
Dog dog = new Dog();// dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的
System.out.println(dog.name);System.out.println(dog.age);
// dog访问的eat()和sleep()方法也是从Animal中继承下来的
dog.eat();
dog.sleep();
dog.bark();
}
}
注意
（1）子类会将父类中的成员变量或者成员方法继承到子类中
（2）子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了
1.3.父类成员的访问
我先提问个问题，在继承体系中，子类将父类中的方法和字段继承下来了，那在子类中能否直接访问父类中继承下来的成员呢？
答案是不一定
（1）父类用 public或protected修饰：子类任何场景都能直接访问
（2）父类用 default 修饰（无修饰符）：子类仅同包时能直接访问
（3）父类用 private 修饰：子类任何场景都不能直接访问
（4）若子类与父类成员同名但类型不同、子类新增和父类同名的对象——子类中直接访问同名成员，优先访问子类自身定义的，父类的同名成员会被 “隐藏”，父类的用 super 访问。
1.3.2子类中访问父类的成员方法
（1）若成员方法名字不同，在子类方法或通过子类对象访问方法时，优先访问自己的，自己没有再到父类找，若父类没有则报错。
（2）若成员方法相同时，通过子类对象访问父类与子类中不同名方法时，优先在子类中找，找到则访问，否则在父类中找，找到则访问，否则编译报错。通过派生类对象访问父类与子类同名方法时，如果父类和子类同名方法的参数列表不同(重载)，根据调用方法适传递的参数选择合适的方法访问，如果没有则报错；
1.4 super关键字
  子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成员时，该如何操作？直接访问是无法做到的，Java提供了super关键字，该关键字主要作用：在子类方法中访问父类的成员。
  【注意事项】
（1） 只能在非静态方法中使用
（2） 在子类方法中，访问父类的成员变量和方法。
1.5子类构造方法
  父子父子，先有父再有子，即：子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。————emmmm，其实听起来还是一头雾水，怎么理解他呢？其实哈，子类构造方法的样子和普通类的构造方法基本一致：和子类同名、没有返回值、可以加参数，核心区别是子类构造方法里一定会「先调用父类的构造方法」（哪怕你没写，Java 也会自动帮你加）。
  用生活例子打比方：父类是「手机」，子类是「智能手机」。造智能手机（子类）的第一步，必须先造好基础的手机机身（父类），再在机身上加触屏、摄像头这些智能手机的专属功能。子类构造方法就是「造智能手机的流程」，父类构造方法是「造基础手机的流程」，子类造东西，必须先把父类的基础部分造好，这就是子类构造方法的核心逻辑。
  注意：
（1）. 若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构
造方法
（2）. 如果父类构造方法是带有参数的，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。
（3）. 在子类构造方法中，super(...)调用父类构造时，必须是子类构造函数中第一条语句。
（4）. super(...)只能在子类构造方法中出现一次，并且不能和this同时出现。
1.6 super和this的关系
  super和this都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？
  【相同点】
（1）. 都是Java中的关键字
（2）. 只能在类的非静态方法中使用，用来访问非静态成员方法和字段
（3）. 在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在
【不同点】
（1）. this是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用
（3）. 在非静态成员方法中，this用来访问本类的方法和属性，super用来访问父类继承下来的方法和属性
（4）. 在构造方法中：this(...)用于调用本类构造方法，super(...)用于调用父类构造方法，两种调用不能同时在构造
方法中出现
（5）. 构造方法中一定会存在super(...)的调用，用户没有写编译器也会增加，但是this(...)用户不写则没有
 1.7再谈初始化
 实例代码块和静态代码块。在没有继承关系时的执行顺序。
（1）. 静态代码块先执行，并且只执行一次，在类加载阶段执行
（2）. 当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行
【继承关系上的执行顺序】
先是父类与子类的静态代码块
然后是父类的实例化代码块与父类的构造代码块
最后才是子类的实例化代码与构造代码块
1.8final关键词
ﬁnal关键可以用来修饰变量、成员方法以及类。
（1）修饰变量或字段，表示常量（即不可修改）
（2）修饰类：表示此类不能被继承
  ——我们平时是用的 String 字符串类, 就是用 ﬁnal 修饰的, 不能被继承.
（3）修饰方法：表示该方法不能被重写
2.多态
2.1多态的概念
  通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同 的状态。一个有趣的例子，在食堂排队打饭时，有个异性插队，同学A的做法：“你插pi的队，排后面去。”另一个同学的做法：“同学，要不这样，你要什么吃的跟我说，我帮你打，等会咱两加个vx，你把钱转我。”————两个同学都在执行遇到插队时该怎么做的行为，却有着不同的结果。
  2.2多态实现的条件
（1）. 必须在继承体系下
（2）. 子类必须要对父类中方法进行重写
（3）. 通过父类的引用调用重写的方法
多态体现：在代码运行时，当传递不同类对象时，会调用对应类中的方法。
    public class Animal {
String name;
int age;
public Animal(String name, int age){this.name = name;this.age = age;
}
public void eat(){
System.out.println(name + "吃饭");}
}
public class Cat extends Animal{public Cat(String name, int age){super(name, age);
}
@Override
public void eat(){
System.out.println(name+"吃鱼~~~");}
}
public class Dog extends Animal {public Dog(String name, int age){super(name, age);
}
@Override
public void eat(){
System.out.println(name+"吃骨头~~~");}
}
///////////////////////////////分割线//////////////////////////////////////////////
public class TestAnimal {
// 编译器在编译代码时，并不知道要调用Dog 还是 Cat 中eat的方法
// 等程序运行起来后，形参a引用的具体对象确定后，才知道调用那个方法
// 注意：此处的形参类型必须时父类类型才可以
public static void eat(Animal a){
a.eat();
}
public static void main(String[] args) {
Cat cat = new Cat("元宝",2);Dog dog = new Dog("小七", 1);
eat(cat);
eat(dog);
}
}
运行结果：
元宝吃鱼~~~
元宝正在睡觉
小七吃骨头~~~
小七正在睡觉

2.3重写
重写也称为覆盖。重写是子类对父类非静态、非private修饰，非ﬁnal修饰，非构造方法等的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。
【方法重写的规则】
子类在重写父类的方法时，一般必须与父类方法原型一致： 返回值类型 方法名 (参数列表) 要完全一致
被重写的方法返回值类型可以不同，但是必须是具有父子关系的
访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类方法被public修饰，则子类中重写该方
法就不能声明为 protected
父类被static、private修饰的方法、构造方法都不能被重写。
重写的方法, 可以使用 @Override 注解来显式指定. 有了这个注解能帮我们进行一些合法性校验. 例如不小心将方法名字拼写错了 (比如写成 aet), 那么此时编译器就会发现父类中没有 aet 方法, 就会编译报错, 提示无法构成重写.
【重写和重载的区别】
区别点    |  重写(override)     | 重载(override)  
参数列表   | 一定不能修改        |   必须修改
返回类型    |一定不能修改        |   可以修改
访问限定符 |一定不能做更严格的限制|    可以修改
